package com.takeico.inspector;

import org.objectweb.asm.ClassReader;
import org.objectweb.asm.ClassVisitor;
import org.objectweb.asm.FieldVisitor;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.Type;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;

/**
 * A CLI application that lists all class files in a specified JAR file
 * and displays their field names and method names using ASM.
 * Can also identify unreferenced classes and members.
 */
public class Main {

    /**
     * Represents information about a class, including its fields and methods.
     */
    private static class ClassInfo {
        String className;
        String superClassName;  // Store the superclass name
        Set<String> fields = new HashSet<>();
        Set<String> methods = new HashSet<>();
        boolean isReferenced = false;

        // Track which fields and methods are referenced
        Set<String> referencedFields = new HashSet<>();
        Set<String> referencedMethods = new HashSet<>();

        public ClassInfo(String className) {
            this.className = className;
        }

        public void addField(String fieldName, String descriptor) {
            fields.add(fieldName + " " + descriptor);
        }

        public void addMethod(String methodName, String descriptor) {
            methods.add(methodName + " " + descriptor);
        }

        public Set<String> getUnreferencedFields() {
            Set<String> unreferenced = new HashSet<>(fields);
            unreferenced.removeAll(referencedFields);
            return unreferenced;
        }

        public Set<String> getUnreferencedMethods() {
            Set<String> unreferenced = new HashSet<>(methods);
            unreferenced.removeAll(referencedMethods);
            // Don't remove constructors and static initializers
            return unreferenced;
        }
    }

    /**
     * A ClassVisitor implementation that collects information about classes, fields, and methods.
     */
    private static class ClassInfoCollector extends ClassVisitor {
        private ClassInfo currentClass;
        private final Map<String, ClassInfo> classInfoMap;

        public ClassInfoCollector(Map<String, ClassInfo> classInfoMap) {
            super(Opcodes.ASM9);
            this.classInfoMap = classInfoMap;
        }

        @Override
        public void visit(int version, int access, String name, String signature, 
                          String superName, String[] interfaces) {
            String className = name.replace('/', '.');
            currentClass = new ClassInfo(className);
            if (superName != null) {
                currentClass.superClassName = superName.replace('/', '.');
            }
            classInfoMap.put(className, currentClass);
        }

        @Override
        public FieldVisitor visitField(int access, String name, String descriptor, 
                                      String signature, Object value) {
            currentClass.addField(name, descriptor);
            return null;
        }

        @Override
        public MethodVisitor visitMethod(int access, String name, String descriptor, 
                                        String signature, String[] exceptions) {
            // Only add methods that are actually defined in this class, not inherited ones
            // Bridge and synthetic methods are generated by the compiler, not directly defined in the source code
            if ((access & (Opcodes.ACC_BRIDGE | Opcodes.ACC_SYNTHETIC)) == 0) {
                currentClass.addMethod(name, descriptor);
            }
            return null;
        }
    }

    /**
     * A MethodVisitor implementation that detects references to other classes, fields, and methods.
     */
    private static class MethodReferenceVisitor extends MethodVisitor {
        private final ReferenceDetector detector;

        public MethodReferenceVisitor(ReferenceDetector detector) {
            super(Opcodes.ASM9);
            this.detector = detector;
        }

        @Override
        public void visitFieldInsn(int opcode, String owner, String name, String descriptor) {
            detector.addFieldReference(owner.replace('/', '.'), name, descriptor);
        }

        @Override
        public void visitMethodInsn(int opcode, String owner, String name, String descriptor, boolean isInterface) {
            detector.addMethodReference(owner.replace('/', '.'), name, descriptor);
        }

        @Override
        public void visitTypeInsn(int opcode, String type) {
            if (type.startsWith("[")) {
                // Handle array types
                Type t = Type.getType(type);
                if (t.getSort() == Type.OBJECT) {
                    detector.addClassReference(t.getClassName());
                }
            } else {
                detector.addClassReference(type.replace('/', '.'));
            }
        }
    }

    /**
     * A ClassVisitor implementation that detects references to other classes, fields, and methods.
     */
    private static class ReferenceDetector extends ClassVisitor {
        private final Map<String, ClassInfo> classInfoMap;
        private String currentClassName;

        public ReferenceDetector(Map<String, ClassInfo> classInfoMap) {
            super(Opcodes.ASM9);
            this.classInfoMap = classInfoMap;
        }

        @Override
        public void visit(int version, int access, String name, String signature, 
                          String superName, String[] interfaces) {
            currentClassName = name.replace('/', '.');

            // Mark superclass as referenced
            if (superName != null) {
                addClassReference(superName.replace('/', '.'));
            }

            // Mark interfaces as referenced
            if (interfaces != null) {
                for (String iface : interfaces) {
                    addClassReference(iface.replace('/', '.'));
                }
            }
        }

        @Override
        public MethodVisitor visitMethod(int access, String name, String descriptor, 
                                        String signature, String[] exceptions) {
            // Process parameter and return types
            Type methodType = Type.getMethodType(descriptor);
            Type returnType = methodType.getReturnType();
            if (returnType.getSort() == Type.OBJECT) {
                addClassReference(returnType.getClassName());
            }

            for (Type paramType : methodType.getArgumentTypes()) {
                if (paramType.getSort() == Type.OBJECT) {
                    addClassReference(paramType.getClassName());
                }
            }

            return new MethodReferenceVisitor(this);
        }

        public void addClassReference(String className) {
            ClassInfo info = classInfoMap.get(className);
            if (info != null) {
                info.isReferenced = true;
            }
        }

        public void addFieldReference(String className, String fieldName, String descriptor) {
            ClassInfo info = classInfoMap.get(className);
            if (info != null) {
                info.referencedFields.add(fieldName + " " + descriptor);
            }
        }

        public void addMethodReference(String className, String methodName, String descriptor) {
            ClassInfo info = classInfoMap.get(className);
            if (info != null) {
                String methodKey = methodName + " " + descriptor;

                // Check if the method exists in this class
                if (info.methods.contains(methodKey)) {
                    // Method exists in this class, mark it as referenced
                    info.referencedMethods.add(methodKey);
                } else {
                    // Method doesn't exist in this class, check parent classes
                    markMethodInParentClass(className, methodKey);
                }
            }
        }

        private void markMethodInParentClass(String className, String methodKey) {
            // Get the class info
            ClassInfo classInfo = classInfoMap.get(className);
            if (classInfo == null) return;

            // Check if this class has a superclass
            if (classInfo.superClassName != null) {
                // Get the superclass info
                ClassInfo superClassInfo = classInfoMap.get(classInfo.superClassName);
                if (superClassInfo != null) {
                    // Check if the method exists in the superclass
                    if (superClassInfo.methods.contains(methodKey)) {
                        // Found the method in the parent class, mark it as referenced
                        superClassInfo.referencedMethods.add(methodKey);
                        return;
                    } else {
                        // Continue searching in the parent's hierarchy
                        markMethodInParentClass(classInfo.superClassName, methodKey);
                    }
                }
            }
        }
    }

    /**
     * A ClassVisitor implementation that extracts and prints field and method information.
     */
    private static class ClassInspectorVisitor extends ClassVisitor {
        private String className;
        private String superClassName;
        private final Map<String, ClassInfo> classInfoMap;
        private int referencedMethodCount = 0;
        private int unreferencedMethodCount = 0;
        private int referencedFieldCount = 0;
        private int unreferencedFieldCount = 0;
        private List<String> methodsInfo = new ArrayList<>();
        private List<String> fieldsInfo = new ArrayList<>();
        private boolean printedMethodsHeader = false;

        public ClassInspectorVisitor(Map<String, ClassInfo> classInfoMap) {
            super(Opcodes.ASM9);
            this.classInfoMap = classInfoMap;
        }

        @Override
        public void visit(int version, int access, String name, String signature, 
                          String superName, String[] interfaces) {
            this.className = name.replace('/', '.');
            this.superClassName = superName != null ? superName.replace('/', '.') : null;

            ClassInfo classInfo = classInfoMap.get(className);

            String typePrefix = (access & Opcodes.ACC_INTERFACE) != 0 ? "Interface: " : "Class: ";
            System.out.println("\n" + typePrefix + className);
            System.out.println("--------------------------------------------------------------------------------");

            if (superName != null) {
                System.out.println("  Superclass: " + superClassName);
            }
        }

        @Override
        public FieldVisitor visitField(int access, String name, String descriptor, 
                                      String signature, Object value) {
            ClassInfo classInfo = classInfoMap.get(className);
            String fieldKey = name + " " + descriptor;

            boolean isReferenced = classInfo != null && classInfo.referencedFields.contains(fieldKey);

            if (isReferenced) {
                referencedFieldCount++;
            } else {
                unreferencedFieldCount++;
            }

            // Store field info for later display
            StringBuilder info = new StringBuilder();
            info.append("    ").append(isReferenced ? "✓" : "✗").append(" ").append(name).append(": ");

            // Convert field descriptor to simple type name
            Type fieldType = Type.getType(descriptor);
            info.append(getSimpleTypeName(fieldType));

            fieldsInfo.add(info.toString());

            // Add reference information
            if (isReferenced) {
                StringBuilder refInfo = new StringBuilder();
                refInfo.append("      Referenced by: ");
                // Find classes that reference this field
                boolean foundReference = false;
                for (Map.Entry<String, ClassInfo> entry : classInfoMap.entrySet()) {
                    if (entry.getValue().referencedFields.contains(fieldKey)) {
                        if (foundReference) {
                            refInfo.append(", ");
                        }
                        refInfo.append(entry.getKey());
                        foundReference = true;
                    }
                }
                fieldsInfo.add(refInfo.toString());
            } else {
                fieldsInfo.add("      Not referenced by any class");
            }

            return null;
        }

        @Override
        public MethodVisitor visitMethod(int access, String name, String descriptor, 
                                        String signature, String[] exceptions) {
            ClassInfo classInfo = classInfoMap.get(className);
            String methodKey = name + " " + descriptor;

            // Skip methods that are not defined in this class (inherited methods)
            // Check if the method is actually defined in this class by checking if it's in the methods set
            if (!classInfo.methods.contains(methodKey)) {
                return null;
            }

            boolean isReferenced = classInfo != null && classInfo.referencedMethods.contains(methodKey);

            if (isReferenced) {
                referencedMethodCount++;
            } else {
                unreferencedMethodCount++;
            }

            // Store method info for later display
            StringBuilder info = new StringBuilder();
            info.append("    ").append(isReferenced ? "✓" : "✗").append(" ").append(name);

            // Format method parameters and return type
            Type methodType = Type.getMethodType(descriptor);
            Type[] paramTypes = methodType.getArgumentTypes();
            Type returnType = methodType.getReturnType();

            // Format parameters
            StringBuilder params = new StringBuilder();
            params.append("(");
            for (int i = 0; i < paramTypes.length; i++) {
                if (i > 0) {
                    params.append(", ");
                }
                params.append(getSimpleTypeName(paramTypes[i]));
            }
            params.append(")");

            // Format return type
            String returnTypeStr = getSimpleTypeName(returnType);

            info.append(params).append(": ").append(returnTypeStr);
            methodsInfo.add(info.toString());

            // Add reference information
            if (isReferenced) {
                StringBuilder refInfo = new StringBuilder();
                refInfo.append("      Referenced by: ");
                // Find classes that reference this method
                boolean foundReference = false;
                for (Map.Entry<String, ClassInfo> entry : classInfoMap.entrySet()) {
                    if (entry.getValue().referencedMethods.contains(methodKey)) {
                        if (foundReference) {
                            refInfo.append(", ");
                        }
                        refInfo.append(entry.getKey());
                        foundReference = true;
                    }
                }
                methodsInfo.add(refInfo.toString());
            } else {
                methodsInfo.add("      Not referenced by any class");
            }

            return null;
        }

        @Override
        public void visitEnd() {
            if (!methodsInfo.isEmpty()) {
                System.out.println("  Methods:");
                for (String info : methodsInfo) {
                    System.out.println(info);
                }
                System.out.println("  Summary: " + referencedMethodCount + " methods referenced, " + 
                                  unreferencedMethodCount + " methods not referenced");
            }

            if (!fieldsInfo.isEmpty()) {
                System.out.println("  Fields:");
                for (String info : fieldsInfo) {
                    System.out.println(info);
                }
                System.out.println("  Summary: " + referencedFieldCount + " fields referenced, " + 
                                  unreferencedFieldCount + " fields not referenced");
            }
        }

        /**
         * Converts an ASM Type object to a simple type name.
         * 
         * @param type The ASM Type object
         * @return A simple string representation of the type
         */
        private String getSimpleTypeName(Type type) {
            switch (type.getSort()) {
                case Type.VOID:
                    return "void";
                case Type.BOOLEAN:
                    return "boolean";
                case Type.CHAR:
                    return "char";
                case Type.BYTE:
                    return "byte";
                case Type.SHORT:
                    return "short";
                case Type.INT:
                    return "int";
                case Type.FLOAT:
                    return "float";
                case Type.LONG:
                    return "long";
                case Type.DOUBLE:
                    return "double";
                case Type.ARRAY:
                    return getSimpleTypeName(type.getElementType()) + "[]";
                case Type.OBJECT:
                    String className = type.getClassName();
                    // Remove package name for common packages
                    if (className.startsWith("java.lang.")) {
                        className = className.substring("java.lang.".length());
                    }
                    // Get simple name for other classes
                    int lastDot = className.lastIndexOf('.');
                    if (lastDot > 0) {
                        className = className.substring(lastDot + 1);
                    }
                    return className;
                default:
                    return type.getClassName();
            }
        }
    }
    public static void main(String[] args) {
        List<String> jarPaths = new ArrayList<>();

        // Parse command line arguments
        for (String arg : args) {
            jarPaths.add(arg);
        }

        if (jarPaths.isEmpty()) {
            System.err.println("Usage: java -jar class-inspector.jar <path-to-jar-file> [<path-to-jar-file> ...]");
            System.exit(1);
        }

        boolean hasErrors = false;

        for (String jarPath : jarPaths) {
            File jarFile = new File(jarPath);

            if (!jarFile.exists() || !jarFile.isFile()) {
                System.err.println("Error: The specified JAR file does not exist or is not a file: " + jarPath);
                hasErrors = true;
                continue;
            }

            try {
                listClassesInJar(jarPath);
            } catch (IOException e) {
                System.err.println("Error reading JAR file " + jarPath + ": " + e.getMessage());
                hasErrors = true;
            }
        }

        if (hasErrors) {
            System.exit(1);
        }
    }

    /**
     * Lists all class files in the specified JAR file and inspects their fields and methods using ASM.
     * Can also identify unreferenced classes and members.
     *
     * @param jarPath Path to the JAR file
     * @throws IOException If there's an error reading the JAR file
     */
    private static void listClassesInJar(String jarPath) throws IOException {
        try (JarFile jar = new JarFile(jarPath)) {
            System.out.println("Inspecting classes in " + jarPath + ":");

            // Step 1: Collect information about all classes, fields, and methods
            Map<String, ClassInfo> classInfoMap = new HashMap<>();
            List<byte[]> classBytes = new ArrayList<>();

            // For overall statistics
            int totalClasses = 0;
            int totalMethods = 0;
            int totalReferencedMethods = 0;
            int totalFields = 0;
            int totalReferencedFields = 0;

            Enumeration<JarEntry> entries = jar.entries();
            while (entries.hasMoreElements()) {
                JarEntry entry = entries.nextElement();
                String name = entry.getName();

                // Only process .class files and skip directories
                if (name.endsWith(".class") && !entry.isDirectory()) {
                    try (InputStream is = jar.getInputStream(entry)) {
                        byte[] bytes = is.readAllBytes();
                        classBytes.add(bytes);

                        // Collect class info
                        ClassReader reader = new ClassReader(bytes);
                        ClassInfoCollector collector = new ClassInfoCollector(classInfoMap);
                        reader.accept(collector, ClassReader.SKIP_DEBUG | ClassReader.SKIP_FRAMES);
                    } catch (Exception e) {
                        System.err.println("Error collecting class info for " + name + ": " + e.getMessage());
                    }
                }
            }

            // Step 2: Detect references between classes, fields, and methods
            for (byte[] bytes : classBytes) {
                try {
                    ClassReader reader = new ClassReader(bytes);
                    ReferenceDetector detector = new ReferenceDetector(classInfoMap);
                    reader.accept(detector, ClassReader.SKIP_DEBUG | ClassReader.SKIP_FRAMES);
                } catch (Exception e) {
                    System.err.println("Error detecting references: " + e.getMessage());
                }
            }

            // Step 3: Display the results
            entries = jar.entries();
            while (entries.hasMoreElements()) {
                JarEntry entry = entries.nextElement();
                String name = entry.getName();

                // Only process .class files and skip directories
                if (name.endsWith(".class") && !entry.isDirectory()) {
                    try (InputStream is = jar.getInputStream(entry)) {
                        // Use ASM to read the class file
                        ClassReader reader = new ClassReader(is);
                        ClassInspectorVisitor visitor = new ClassInspectorVisitor(classInfoMap);

                        // Accept the visitor to extract and display field and method information
                        reader.accept(visitor, ClassReader.SKIP_DEBUG | ClassReader.SKIP_FRAMES);

                        // Count this class for statistics
                        totalClasses++;
                    } catch (Exception e) {
                        System.err.println("Error inspecting class " + name + ": " + e.getMessage());
                    }
                }
            }

            // Calculate overall statistics
            for (ClassInfo classInfo : classInfoMap.values()) {
                totalMethods += classInfo.methods.size();
                totalFields += classInfo.fields.size();
                totalReferencedMethods += classInfo.referencedMethods.size();
                totalReferencedFields += classInfo.referencedFields.size();
            }

            // Display overall statistics
            System.out.println("\nOverall Statistics:");
            System.out.println("================================================================================");
            System.out.println("Total classes: " + totalClasses);
            System.out.println("Total methods: " + totalMethods + 
                              " (Referenced: " + totalReferencedMethods + 
                              ", Not referenced: " + (totalMethods - totalReferencedMethods) + ")");
            System.out.println("Total fields: " + totalFields + 
                              " (Referenced: " + totalReferencedFields + 
                              ", Not referenced: " + (totalFields - totalReferencedFields) + ")");
        }
    }
}
